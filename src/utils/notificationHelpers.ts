import FirebaseNotificationService from "./firebaseNotificationService";
import ExpoNotificationService from "./expoNotificationService";
import {
  sendExpoOrderCreatedNotification,
  sendExpoOrderStatusUpdatedNotification,
  sendExpoOrderShippedNotification,
  sendExpoOrderDeliveredNotification,
  sendExpoOrderCancelledNotification,
  sendExpoPromotionalNotification,
} from "./expoNotificationHelpers";
import { Types } from "mongoose";

const notificationService = FirebaseNotificationService.getInstance();
const expoNotificationService = ExpoNotificationService.getInstance();

export interface OrderData {
  _id: string | Types.ObjectId;
  orderCode: string;
  userId: string | Types.ObjectId;
  totalAmount: number;
  status: string;
  user?: {
    name: string;
    email: string;
  };
}

/**
 * Send notification when a new order is created
 */
export const sendOrderCreatedNotification = async (orderData: OrderData) => {
  try {
    // Send both FCM and Expo notifications
    const [fcmResult, expoResult] = await Promise.allSettled([
      notificationService.sendOrderNotification({
        userId: orderData.userId,
        orderId: orderData._id,
        orderCode: orderData.orderCode,
        type: "order_created",
        title: "üéâ ƒê·∫∑t h√†ng th√†nh c√¥ng!",
        body: `ƒê∆°n h√†ng #${orderData.orderCode} c·ªßa b·∫°n ƒë√£ ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng v·ªõi t·ªïng gi√° tr·ªã ${formatCurrency(
          orderData.totalAmount
        )}. Ch√∫ng t√¥i s·∫Ω x·ª≠ l√Ω ƒë∆°n h√†ng trong th·ªùi gian s·ªõm nh·∫•t.`,
        data: {
          orderCode: orderData.orderCode,
          totalAmount: orderData.totalAmount,
          status: orderData.status,
          clickAction: `/account/orders/${orderData.orderCode}`,
        },
      }),
      sendExpoOrderCreatedNotification(orderData),
    ]);

    console.log(
      `Order created notifications sent for order ${orderData.orderCode}:`,
      { fcm: fcmResult, expo: expoResult }
    );

    // Return success if at least one notification was sent successfully
    const fcmSuccess =
      fcmResult.status === "fulfilled" && fcmResult.value.success;
    const expoSuccess =
      expoResult.status === "fulfilled" && expoResult.value.success;

    return {
      success: fcmSuccess || expoSuccess,
      fcm: fcmResult,
      expo: expoResult,
    };
  } catch (error) {
    console.error("Error sending order created notification:", error);
    return { success: false, error: (error as Error).message };
  }
};

/**
 * Send notification when order status is updated
 */
export const sendOrderStatusUpdatedNotification = async (
  orderData: OrderData,
  oldStatus: string,
  newStatus: string,
  adminNotes?: string
) => {
  try {
    const { title, body, type } = getStatusUpdateMessage(
      newStatus,
      orderData.orderCode,
      adminNotes
    );

    // Send both FCM and Expo notifications
    const [fcmResult, expoResult] = await Promise.allSettled([
      notificationService.sendOrderNotification({
        userId: orderData.userId,
        orderId: orderData._id,
        orderCode: orderData.orderCode,
        type: type as any,
        title,
        body,
        data: {
          orderCode: orderData.orderCode,
          oldStatus,
          newStatus,
          totalAmount: orderData.totalAmount,
          adminNotes,
          clickAction: `/account/orders/${orderData.orderCode}`,
        },
      }),
      sendExpoOrderStatusUpdatedNotification(
        orderData,
        oldStatus,
        newStatus,
        adminNotes
      ),
    ]);

    console.log(
      `Order status update notifications sent for order ${orderData.orderCode}:`,
      { fcm: fcmResult, expo: expoResult }
    );

    // Return success if at least one notification was sent successfully
    const fcmSuccess =
      fcmResult.status === "fulfilled" && fcmResult.value.success;
    const expoSuccess =
      expoResult.status === "fulfilled" && expoResult.value.success;

    return {
      success: fcmSuccess || expoSuccess,
      fcm: fcmResult,
      expo: expoResult,
    };
  } catch (error) {
    console.error("Error sending order status update notification:", error);
    return { success: false, error: (error as Error).message };
  }
};

/**
 * Send notification when order is shipped
 */
export const sendOrderShippedNotification = async (
  orderData: OrderData,
  trackingInfo?: { trackingNumber?: string; carrier?: string }
) => {
  try {
    let body = `ƒê∆°n h√†ng #${orderData.orderCode} ƒë√£ ƒë∆∞·ª£c giao cho ƒë·ªëi t√°c v·∫≠n chuy·ªÉn v√† ƒëang tr√™n ƒë∆∞·ªùng ƒë·∫øn b·∫°n.`;

    if (trackingInfo?.trackingNumber) {
      body += ` M√£ v·∫≠n ƒë∆°n: ${trackingInfo.trackingNumber}`;
    }

    // Send both FCM and Expo notifications
    const [fcmResult, expoResult] = await Promise.allSettled([
      notificationService.sendOrderNotification({
        userId: orderData.userId,
        orderId: orderData._id,
        orderCode: orderData.orderCode,
        type: "order_shipped",
        title: "üöö ƒê∆°n h√†ng ƒëang ƒë∆∞·ª£c giao!",
        body,
        data: {
          orderCode: orderData.orderCode,
          trackingNumber: trackingInfo?.trackingNumber,
          carrier: trackingInfo?.carrier,
          clickAction: `/account/orders/${orderData.orderCode}`,
        },
      }),
      sendExpoOrderShippedNotification(orderData, trackingInfo),
    ]);

    console.log(
      `Order shipped notifications sent for order ${orderData.orderCode}:`,
      { fcm: fcmResult, expo: expoResult }
    );

    // Return success if at least one notification was sent successfully
    const fcmSuccess =
      fcmResult.status === "fulfilled" && fcmResult.value.success;
    const expoSuccess =
      expoResult.status === "fulfilled" && expoResult.value.success;

    return {
      success: fcmSuccess || expoSuccess,
      fcm: fcmResult,
      expo: expoResult,
    };
  } catch (error) {
    console.error("Error sending order shipped notification:", error);
    return { success: false, error: (error as Error).message };
  }
};

/**
 * Send notification when order is delivered
 */
export const sendOrderDeliveredNotification = async (orderData: OrderData) => {
  try {
    // Send both FCM and Expo notifications
    const [fcmResult, expoResult] = await Promise.allSettled([
      notificationService.sendOrderNotification({
        userId: orderData.userId,
        orderId: orderData._id,
        orderCode: orderData.orderCode,
        type: "order_delivered",
        title: "‚úÖ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c giao!",
        body: `ƒê∆°n h√†ng #${orderData.orderCode} ƒë√£ ƒë∆∞·ª£c giao th√†nh c√¥ng. C·∫£m ∆°n b·∫°n ƒë√£ mua s·∫Øm t·∫°i Ryxel Store! ƒê·ª´ng qu√™n ƒë√°nh gi√° s·∫£n ph·∫©m nh√©.`,
        data: {
          orderCode: orderData.orderCode,
          clickAction: `/account/orders/${orderData.orderCode}`,
          showReviewPrompt: true,
        },
      }),
      sendExpoOrderDeliveredNotification(orderData),
    ]);

    console.log(
      `Order delivered notifications sent for order ${orderData.orderCode}:`,
      { fcm: fcmResult, expo: expoResult }
    );

    // Return success if at least one notification was sent successfully
    const fcmSuccess =
      fcmResult.status === "fulfilled" && fcmResult.value.success;
    const expoSuccess =
      expoResult.status === "fulfilled" && expoResult.value.success;

    return {
      success: fcmSuccess || expoSuccess,
      fcm: fcmResult,
      expo: expoResult,
    };
  } catch (error) {
    console.error("Error sending order delivered notification:", error);
    return { success: false, error: (error as Error).message };
  }
};

/**
 * Send notification when order is cancelled
 */
export const sendOrderCancelledNotification = async (
  orderData: OrderData,
  reason?: string,
  refundInfo?: { amount: number; method: string; timeline: string }
) => {
  try {
    let body = `ƒê∆°n h√†ng #${orderData.orderCode} ƒë√£ ƒë∆∞·ª£c h·ªßy.`;

    if (reason) {
      body += ` L√Ω do: ${reason}`;
    }

    if (refundInfo) {
      body += ` S·ªë ti·ªÅn ${formatCurrency(refundInfo.amount)} s·∫Ω ƒë∆∞·ª£c ho√†n l·∫°i qua ${refundInfo.method} trong v√≤ng ${refundInfo.timeline}.`;
    }

    // Send both FCM and Expo notifications
    const [fcmResult, expoResult] = await Promise.allSettled([
      notificationService.sendOrderNotification({
        userId: orderData.userId,
        orderId: orderData._id,
        orderCode: orderData.orderCode,
        type: "order_cancelled",
        title: "‚ùå ƒê∆°n h√†ng ƒë√£ b·ªã h·ªßy",
        body,
        data: {
          orderCode: orderData.orderCode,
          reason,
          refundInfo,
          clickAction: `/account/orders/${orderData.orderCode}`,
        },
      }),
      sendExpoOrderCancelledNotification(orderData, reason, refundInfo),
    ]);

    console.log(
      `Order cancelled notifications sent for order ${orderData.orderCode}:`,
      { fcm: fcmResult, expo: expoResult }
    );

    // Return success if at least one notification was sent successfully
    const fcmSuccess =
      fcmResult.status === "fulfilled" && fcmResult.value.success;
    const expoSuccess =
      expoResult.status === "fulfilled" && expoResult.value.success;

    return {
      success: fcmSuccess || expoSuccess,
      fcm: fcmResult,
      expo: expoResult,
    };
  } catch (error) {
    console.error("Error sending order cancelled notification:", error);
    return { success: false, error: (error as Error).message };
  }
};

/**
 * Send promotional notification
 */
export const sendPromotionalNotification = async (
  userIds: (string | Types.ObjectId)[] | "all",
  title: string,
  body: string,
  data?: Record<string, any>,
  imageUrl?: string
) => {
  try {
    const payload = { title, body, data, imageUrl };

    // Send both FCM and Expo notifications
    const [fcmResult, expoResult] = await Promise.allSettled([
      userIds === "all"
        ? notificationService.sendToAllUsers(payload, "promotion")
        : notificationService.sendToMultipleUsers(
            userIds,
            payload,
            "promotion"
          ),
      sendExpoPromotionalNotification(userIds, title, body, data),
    ]);

    console.log(`Promotional notifications sent:`, {
      fcm: fcmResult,
      expo: expoResult,
    });

    // Return success if at least one notification was sent successfully
    const fcmSuccess =
      fcmResult.status === "fulfilled" && fcmResult.value.success;
    const expoSuccess =
      expoResult.status === "fulfilled" && expoResult.value.success;

    return {
      success: fcmSuccess || expoSuccess,
      fcm: fcmResult,
      expo: expoResult,
    };
  } catch (error) {
    console.error("Error sending promotional notification:", error);
    return { success: false, error: (error as Error).message };
  }
};

/**
 * Get status update message based on new status
 */
function getStatusUpdateMessage(
  status: string,
  orderCode: string,
  adminNotes?: string
) {
  const messages: Record<
    string,
    { title: string; body: string; type: string }
  > = {
    confirmed: {
      title: "‚úÖ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n!",
      body: `ƒê∆°n h√†ng #${orderCode} ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n v√† ƒëang ƒë∆∞·ª£c chu·∫©n b·ªã. ${
        adminNotes || "Ch√∫ng t√¥i s·∫Ω s·ªõm giao h√†ng cho b·∫°n."
      }`,
      type: "order_status_updated",
    },
    preparing: {
      title: "üì¶ ƒêang chu·∫©n b·ªã ƒë∆°n h√†ng",
      body: `ƒê∆°n h√†ng #${orderCode} ƒëang ƒë∆∞·ª£c chu·∫©n b·ªã. ${
        adminNotes || "Ch√∫ng t√¥i ƒëang ƒë√≥ng g√≥i s·∫£n ph·∫©m cho b·∫°n."
      }`,
      type: "order_status_updated",
    },
    ready_to_ship: {
      title: "üöÄ ƒê∆°n h√†ng s·∫µn s√†ng giao",
      body: `ƒê∆°n h√†ng #${orderCode} ƒë√£ ƒë∆∞·ª£c chu·∫©n b·ªã xong v√† s·∫µn s√†ng giao. ${
        adminNotes || "ƒê∆°n h√†ng s·∫Ω s·ªõm ƒë∆∞·ª£c giao cho ƒë·ªëi t√°c v·∫≠n chuy·ªÉn."
      }`,
      type: "order_status_updated",
    },
    shipping: {
      title: "üöö ƒê∆°n h√†ng ƒëang ƒë∆∞·ª£c giao!",
      body: `ƒê∆°n h√†ng #${orderCode} ƒëang tr√™n ƒë∆∞·ªùng ƒë·∫øn b·∫°n. ${
        adminNotes || "Vui l√≤ng ch√∫ √Ω ƒëi·ªán tho·∫°i ƒë·ªÉ nh·∫≠n h√†ng."
      }`,
      type: "order_shipped",
    },
    delivered: {
      title: "‚úÖ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c giao!",
      body: `ƒê∆°n h√†ng #${orderCode} ƒë√£ ƒë∆∞·ª£c giao th√†nh c√¥ng. ${
        adminNotes || "C·∫£m ∆°n b·∫°n ƒë√£ mua s·∫Øm t·∫°i Ryxel Store!"
      }`,
      type: "order_delivered",
    },
    cancelled: {
      title: "‚ùå ƒê∆°n h√†ng ƒë√£ b·ªã h·ªßy",
      body: `ƒê∆°n h√†ng #${orderCode} ƒë√£ ƒë∆∞·ª£c h·ªßy. ${
        adminNotes || "Vui l√≤ng li√™n h·ªá v·ªõi ch√∫ng t√¥i n·∫øu c√≥ th·∫Øc m·∫Øc."
      }`,
      type: "order_cancelled",
    },
    refunded: {
      title: "üí∞ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c ho√†n ti·ªÅn",
      body: `ƒê∆°n h√†ng #${orderCode} ƒë√£ ƒë∆∞·ª£c ho√†n ti·ªÅn. ${
        adminNotes ||
        "S·ªë ti·ªÅn s·∫Ω ƒë∆∞·ª£c chuy·ªÉn v·ªÅ t√†i kho·∫£n c·ªßa b·∫°n trong v√†i ng√†y l√†m vi·ªác."
      }`,
      type: "order_status_updated",
    },
  };

  return (
    messages[status] || {
      title: "üì± C·∫≠p nh·∫≠t ƒë∆°n h√†ng",
      body: `ƒê∆°n h√†ng #${orderCode} ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh "${status}". ${
        adminNotes || ""
      }`,
      type: "order_status_updated",
    }
  );
}

/**
 * Format currency to VND
 */
function formatCurrency(amount: number): string {
  return new Intl.NumberFormat("vi-VN", {
    style: "currency",
    currency: "VND",
  }).format(amount);
}

export { notificationService as FirebaseNotificationService };
